// -*- coding: utf-8 -*-
// Copyright (C) 2018 Laboratoire de Recherche et
// Developpement de l'Epita
//
// This file is part of Spot, a model checking library.
//
// Spot is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
//
// Spot is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
// License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#pragma once
#include <spot/dmc/message.hh>

// Ignore all errors generated by the compiler when including the mpi library.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsuggest-override"
#pragma GCC diagnostic ignored "-Wzero-as-null-pointer-constant"
#include <mpi.h>
#pragma GCC diagnostic pop

namespace spot
{
template <class T>
message<T>::message(int rank, T* send, T* recv, int size, int tag,
                    MPI_Datatype type)
{
  this->send_buffer = send;
  this->recv_buffer = recv;
  this->size = size;
  this->rank = rank;
  this->tag = tag;
  this->flag = 0;
  this->type = type;
  this->persistent_request = new MPI_Request[size];
  this->request = MPI_REQUEST_NULL;
  this->msg = MPI_MESSAGE_NULL;
}

template <class T>
message<T>::~message(void)
{}

template <class T>
int message<T>::get_size(void)
{
  return this->size;
}

// Returns the flag updated by a call to a function of the probe family.
template <class T>
int message<T>::get_flag(void)
{
  return this->flag;
}

template <class T>
int message<T>::async_send(int dest)
{
  return MPI_Isend(this->send_buffer, this->size, this->type, dest, this->tag,
                   MPI_COMM_WORLD, &this->request);
}

/* This function acts like a mailbox.
   It notifies the arrival of a message by putting the flag at 1. */
template <class T>
int message<T>::async_probe(int src)
{
  int ret_val = 0;
  MPI_Status status;
  this->flag = 0;
  this->msg = MPI_MESSAGE_NULL;

  ret_val = MPI_Improbe(src, this->tag, MPI_COMM_WORLD, &this->flag, &this->msg,
                        &status);
  this->status = status;

  return ret_val;
}

// This function retrieves the message associated with the notification.
template <class T>
int message<T>::match_async_recv(void)
{
  /* If the user did not voluntarily provide a buffer to retrieve the message,
     a temporary buffer is used.
     Retrieving a message is cheaper than cancelling a request. */
  if (this->recv_buffer == nullptr)
    {
      T* recv_buf = new T[this->size];
      return MPI_Imrecv(recv_buf, this->size, this->type, &this->msg,
                        &this->request);
      delete[] recv_buf;
    }

  else
    return MPI_Imrecv(this->recv_buffer, this->size, this->type, &this->msg,
                      &this->request);
}

/* Initializes a persistent communication. This last one is associated
   to a request. each request corresponds to a persistent communication. */
template <class T>
int message<T>::init_persistent_send(int dest)
{
  return MPI_Send_init(this->send_buffer, this->size, this->type, dest,
                       this->tag, MPI_COMM_WORLD,
                       &this->persistent_request[dest]);
}

// Start sending a message via a persistent channel
template <class T>
int message<T>::start_persistent_send(int dest)
{
  return MPI_Start(&this->persistent_request[dest]);
}
}  // namespace spot
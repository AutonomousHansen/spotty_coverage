// -*- coding: utf-8 -*-
// Copyright (C) 2018 Laboratoire de Recherche et
// Developpement de l'Epita
//
// This file is part of Spot, a model checking library.
//
// Spot is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your option) any later version.
//
// Spot is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
// License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include "config.h"

#include <iostream>
#include <spot/dmc/process.hh>
#include <string>

// Ignore all errors generated by the compiler when including the mpi library.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsuggest-override"
#pragma GCC diagnostic ignored "-Wzero-as-null-pointer-constant"
#include <mpi.h>
#pragma GCC diagnostic pop

namespace spot
{
/* Initializes the communication context
   according to the desired multithreads support. */
process::process(int nb_threads)
{
  int lenght = 0;

  if (nb_threads > 1)
    MPI_Init_thread(nullptr, nullptr, MPI_THREAD_MULTIPLE,
                    &this->thread_level_support);

  else
    MPI_Init(nullptr, nullptr);

  MPI_Comm_size(MPI_COMM_WORLD, &this->size);
  MPI_Comm_rank(MPI_COMM_WORLD, &this->rank);
  MPI_Get_processor_name(this->host_name, &lenght);

  this->out.str("");
  this->err.str("");
}

process::~process(void)
{
  MPI_Finalize();
}

int process::get_size(void)
{
  return this->size;
}

int process::get_rank(void)
{
  return this->rank;
}

char* process::get_host_name(void)
{
  return this->host_name;
}

void process::print(void)
{
  /* All processes send their output string stream
     to the master process (rank 0). */
  if (this->rank != 0)
    {
      const std::string& str_err(this->err.str());
      const std::string& str_out(this->out.str());
      const char* cstr_err = str_err.c_str();
      const char* cstr_out = str_out.c_str();

      if (!str_err.empty())
        MPI_Send(cstr_err, str_err.size(), MPI_CHAR, 0, 0, MPI_COMM_WORLD);

      if (!str_out.empty())
        MPI_Send(cstr_out, str_out.size(), MPI_CHAR, 0, 0, MPI_COMM_WORLD);
    }

  // Wait until everything is sent to them to be treated.
  MPI_Barrier(MPI_COMM_WORLD);

  // The master process retrieves the sent string streams.
  if (this->rank == 0)
    {
      const std::string& str_err(this->err.str());
      const std::string& str_out(this->out.str());
      char* cstr_err = nullptr;
      char* cstr_out = nullptr;

      if (!str_err.empty())
        std::cerr << str_err << std::endl;

      for (int id = 1; id < this->size; id++)
        {
          MPI_Status status;
          MPI_Message message = MPI_MESSAGE_NULL;
          int flag = 0;
          int lenght = 0;

          /* This function acts like a mailbox. 
             It notifies the arrival of a message by putting the flag at 1. */
          MPI_Improbe(id, 0, MPI_COMM_WORLD, &flag, &message, &status);

          if (flag)
            {
              MPI_Get_count(&status, MPI_CHAR, &lenght);
              cstr_err = new char[lenght];
              MPI_Mrecv(cstr_err, lenght, MPI_CHAR, &message, &status);
              std::cerr << cstr_err << std::endl;
              delete[] cstr_err;
            }
        }

      if (!str_out.empty())
        std::cout << str_out << std::endl;

      for (int id = 1; id < size; id++)
        {
          MPI_Status status;
          MPI_Message message = MPI_MESSAGE_NULL;
          int flag = 0;
          int lenght = 0;

          MPI_Improbe(id, 0, MPI_COMM_WORLD, &flag, &message, &status);

          if (flag)
            {
              MPI_Get_count(&status, MPI_CHAR, &lenght);
              cstr_out = new char[lenght];
              MPI_Mrecv(cstr_out, lenght, MPI_CHAR, &message, &status);
              std::cout << cstr_out << std::endl;
              delete[] cstr_out;
            }
        }
    }
}
}  // namespace spot